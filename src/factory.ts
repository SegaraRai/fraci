import { getSmallestInteger } from "./lib/decimal.js";
import {
  avoidConflictSuffix,
  generateKeyBetween,
  generateNKeysBetween,
} from "./lib/fractional-indexing.js";
import type { FractionalIndex } from "./lib/types.js";
import { createDigitBaseMap, createIntegerLengthBaseMap } from "./lib/utils.js";

export const DEFAULT_MAX_LENGTH = 50;
export const DEFAULT_MAX_RETRIES = 10;

type FractionalIndexPattern<D extends string, L extends string> = `${L}${D}...`;

type StringToUnion<T extends string> = T extends `${infer First}${infer Rest}`
  ? First | StringToUnion<Rest>
  : never;

export interface FractionalIndexing<D extends string, L extends string, X> {
  readonly __EXAMPLE__?: FractionalIndexPattern<
    StringToUnion<D>,
    StringToUnion<L>
  >;

  readonly digitBase: string;
  readonly lengthBase: string;
  generateKeyBetween(
    a: FractionalIndex<D, L, X> | null,
    b: FractionalIndex<D, L, X> | null
  ): Generator<FractionalIndex<D, L, X>, void, unknown>;
  generateNKeysBetween(
    a: FractionalIndex<D, L, X> | null,
    b: FractionalIndex<D, L, X> | null,
    n: number
  ): Generator<FractionalIndex<D, L, X>[], void, unknown>;
}

export interface FractionalIndexingFactoryOptions<
  D extends string,
  L extends string
> {
  digitBase: D;
  lengthBase: L;
  maxLength?: number;
  maxRetries?: number;
}

export function createFractionalIndexing<
  D extends string,
  L extends string,
  X
>({
  digitBase,
  lengthBase,
  maxLength = DEFAULT_MAX_LENGTH,
  maxRetries = DEFAULT_MAX_RETRIES,
}: FractionalIndexingFactoryOptions<D, L>): FractionalIndexing<D, L, X> {
  type F = FractionalIndex<D, L, X>;

  const [digBaseForward, digBaseReverse] = createDigitBaseMap(digitBase);
  const [lenBaseForward, lenBaseReverse] =
    createIntegerLengthBaseMap(lengthBase);
  const smallestInteger = getSmallestInteger(digBaseForward, lenBaseForward);

  return {
    digitBase,
    lengthBase,
    *generateKeyBetween(a: F | null, b: F | null) {
      const base = generateKeyBetween(
        a,
        b,
        digBaseForward,
        digBaseReverse,
        lenBaseForward,
        lenBaseReverse,
        smallestInteger
      );
      if (!base) {
        // Logic Error. Should not happen if a and b are valid (i.e. generated by this library with same digitBase and lengthBase).
        throw new Error("Failed to generate index");
      }

      for (let i = 0; i < maxRetries; i++) {
        const value = `${base}${avoidConflictSuffix(i, digBaseForward)}`;
        if (value.length > maxLength) {
          throw new Error("Exceeded maximum length");
        }
        yield value as F;
      }
    },
    *generateNKeysBetween(a: F | null, b: F | null, n: number) {
      const base = generateNKeysBetween(
        a,
        b,
        n,
        digBaseForward,
        digBaseReverse,
        lenBaseForward,
        lenBaseReverse,
        smallestInteger
      );
      if (!base) {
        // Logic Error. Should not happen if a and b are valid (i.e. generated by this library with same digitBase and lengthBase).
        throw new Error("Failed to generate index");
      }

      const longest = base.reduce((acc, v) => Math.max(acc, v.length), 0);
      for (let i = 0; i < maxRetries; i++) {
        const suffix = avoidConflictSuffix(i, digBaseForward);
        if (longest + suffix.length > maxLength) {
          throw new Error("Exceeded maximum length");
        }
        yield base.map((v) => `${v}${suffix}` as F);
      }
    },
  };
}
