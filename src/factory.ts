import { getSmallestInteger } from "./lib/decimal.js";
import {
  avoidConflictSuffix,
  generateKeyBetween,
  generateNKeysBetween,
} from "./lib/fractional-indexing.js";
import type { FractionalIndex } from "./lib/types.js";
import { createDigitBaseMap, createIntegerLengthBaseMap } from "./lib/utils.js";

export const DEFAULT_MAX_LENGTH = 50;
export const DEFAULT_MAX_RETRIES = 5;

/**
 * Fractional indexing utility.
 */
export interface Fraci<D extends string, L extends string, X> {
  readonly digitBase: D;
  readonly lengthBase: L;
  generateKeyBetween(
    a: FractionalIndex<D, L, X> | null,
    b: FractionalIndex<D, L, X> | null
  ): Generator<FractionalIndex<D, L, X>, void, unknown>;
  generateNKeysBetween(
    a: FractionalIndex<D, L, X> | null,
    b: FractionalIndex<D, L, X> | null,
    n: number
  ): Generator<FractionalIndex<D, L, X>[], void, unknown>;
}

/**
 * Fractional indexing factory options.
 */
export interface FraciOptions<D extends string, L extends string> {
  digitBase: D;
  lengthBase: L;
  maxLength?: number;
  maxRetries?: number;
}

export type FraciCache = Map<string, unknown> & { __fraci__: never };

/**
 * Create cache.
 *
 * @returns Cache
 */
export function createFraciCache(): FraciCache {
  return new Map() as FraciCache;
}

function withCache<T>(
  cache: FraciCache | undefined,
  key: string,
  fn: () => T
): T {
  if (!cache) {
    return fn();
  }

  let value = cache.get(key) as T | undefined;
  if (value === undefined) {
    value = fn();
    cache.set(key, value);
  }

  return value;
}

/**
 * Create fractional indexing utility.
 *
 * @param options Options
 * @param cache Cache (optional)
 * @returns Fractional indexing utility
 */
export function fraci<D extends string, L extends string, X>(
  {
    digitBase,
    lengthBase,
    maxLength = DEFAULT_MAX_LENGTH,
    maxRetries = DEFAULT_MAX_RETRIES,
  }: FraciOptions<D, L>,
  cache?: FraciCache
): Fraci<D, L, X> {
  type F = FractionalIndex<D, L, X>;

  const [digBaseForward, digBaseReverse] = withCache(
    cache,
    `D${digitBase}`,
    createDigitBaseMap.bind(null, digitBase)
  );
  const [lenBaseForward, lenBaseReverse] = withCache(
    cache,
    `L${lengthBase}`,
    createIntegerLengthBaseMap.bind(null, lengthBase)
  );
  const smallestInteger = getSmallestInteger(digBaseForward, lenBaseForward);

  return {
    digitBase,
    lengthBase,
    *generateKeyBetween(a: F | null, b: F | null) {
      const base = generateKeyBetween(
        a,
        b,
        digBaseForward,
        digBaseReverse,
        lenBaseForward,
        lenBaseReverse,
        smallestInteger
      );
      if (!base) {
        // Logic Error. Should not happen if a and b are valid (i.e. generated by this library with same digitBase and lengthBase).
        throw new Error("Failed to generate index");
      }

      for (let i = 0; i < maxRetries; i++) {
        const value = `${base}${avoidConflictSuffix(i, digBaseForward)}`;
        if (value.length > maxLength) {
          throw new Error("Exceeded maximum length");
        }
        yield value as F;
      }
    },
    *generateNKeysBetween(a: F | null, b: F | null, n: number) {
      const base = generateNKeysBetween(
        a,
        b,
        n,
        digBaseForward,
        digBaseReverse,
        lenBaseForward,
        lenBaseReverse,
        smallestInteger
      );
      if (!base) {
        // Logic Error. Should not happen if a and b are valid (i.e. generated by this library with same digitBase and lengthBase).
        throw new Error("Failed to generate index");
      }

      const longest = base.reduce((acc, v) => Math.max(acc, v.length), 0);
      for (let i = 0; i < maxRetries; i++) {
        const suffix = avoidConflictSuffix(i, digBaseForward);
        if (longest + suffix.length > maxLength) {
          throw new Error("Exceeded maximum length");
        }
        yield base.map((v) => `${v}${suffix}` as F);
      }
    },
  };
}
